using System;
using Aran.Geometries;

namespace Aran.PANDA.Common
{
	public static class ARANMath
	{
		#region "Constants"
		public const double C_E = 2.71828182845904523536;
		private const double C_LOG2E = 1.44269504088896340736;
		public const double C_LOG10E = 0.434294481903251827651;
		public const double C_LN2 = 0.693147180559945309417;
		public const double C_LN10 = 2.30258509299404568402;

		public const double C_PI = 3.1415926535897932384626433832795;
		public const double C_2xPI = 2 * C_PI;
		public const double C_PI_2 = C_PI * 0.5;					//	PI / 2.0
		public const double C_1_PI = 0.318309886183790671538;		//	1.0 / PI
		public const double C_2_PI = 0.636619772367581343076;		//	2.0 / PI
		public const double C_1_SQRTPI = 0.564189583547756286948;	//	1.0 / Sqrt(PI)
		public const double C_2_SQRTPI = 1.12837916709551257390;	//	2.0 / Sqrt(PI)
		public const double C_SQRT2 = 1.41421356237309504880;		//	Sqrt(2.0)
		public const double C_SQRT_2 = 0.707106781186547524401;		//	Sqrt(2.0) / 2.0
		public const double C_SQRT3 = 1.7320508075688772935274463415059;		//	Sqrt(3.0)
		public const double C_SQRT_3 = 0.57735026918962576450914878050196;		//	1.0/Sqrt(3.0)

		public const double DegToRadValue = C_PI / 180.0;
		public const double RadToDegValue = 180.0 / C_PI;

		public const double Epsilon = 10e-8;
		public const double EpsilonDistance = 0.001;
		public const double Epsilon_2Distance = EpsilonDistance * EpsilonDistance;
		public const double EpsilonDegree = 2.0 / 3600.0;
		public const double EpsilonRadian = EpsilonDegree / 360.0;
		#endregion

		#region "Elementery Math"
		public static double Sqr(double val)
		{
			return val * val;
		}

		public static double RadToDeg(double rad)
		{
			return rad * RadToDegValue;
		}

		public static double DegToRad(double deg)
		{
			return deg * DegToRadValue;
		}

		public static string DegToStr(double V)
		{
			string result = System.Convert.ToString(V);
			int l = result.Length;

			for (int i = 0; i < 3 - l; i++)
				result = "0" + result;

			return result + "°";
		}

		public static double Modulus(double x, double y = 360.0)
		{
			x = x - Math.Floor(x / y) * y;

			if (x < 0.0)
				x = x + y;

			if (x == y)
				return 0.0;

			return x;
		}

		public static double Hypot(double x, double y)
		{
			x = Math.Abs(x);
			y = Math.Abs(y);
			double fTmp;

			if (x > y)
			{
				fTmp = x;
				x = y;
				y = fTmp;
			}

			if (x == 0)
				return y;

			fTmp = x / y;
			return y * Math.Sqrt(1.0 + fTmp * fTmp);
		}

		public static double SubtractAngles(double X, double Y)
		{
			X = Modulus(X, C_2xPI);
			Y = Modulus(Y, C_2xPI);

			double result = Modulus(X - Y, C_2xPI);
			if (result > C_PI)
				result = C_2xPI - result;

			return result;
		}

        public static double SubtractAnglesInDegs(double degX, double degY)
        {
            double result = Modulus(degX - degY, 360.0);
            if (result > 180.0)
                result = 360.0 - result;
            return result;
        }

		public static double SubtractAnglesWithSign(double startRad, double endRad, SideDirection side)
		{
			double result = Modulus((endRad - startRad) * (int)(side), C_2xPI);
			if (result > C_PI)
				result = result - C_2xPI;
			return result;
		}
		#endregion

		#region "Rounding Math"

		public static double AdvancedRound(double Value, double Accuracy, eRoundMode RoundMode)
		{
			if (RoundMode >= eRoundMode.FLOOR && RoundMode <= eRoundMode.CEIL)
			{
				double nValue = Value / Accuracy;

				if (System.Math.Abs(nValue - System.Math.Round(nValue)) < Epsilon)
					RoundMode = eRoundMode.NEAREST;

				switch (RoundMode)
				{
					case eRoundMode.FLOOR:
						return Math.Floor(nValue) * Accuracy;
					case eRoundMode.NEAREST:
						return System.Math.Round(nValue) * Accuracy;
					case eRoundMode.CEIL:
						return Math.Ceiling(nValue) * Accuracy;
				}
			}
			return Value;
		}

		public static string RoundToStr(double Value, double Accuracy, eRoundMode roundMode = eRoundMode.NEAREST)
		{
			string s = "0";
			double n = Math.Log10(Accuracy);
			if (n < 0)
				s = "0." + new String('#', (int)Math.Ceiling(-n));

			return AdvancedRound(Value, Accuracy, roundMode).ToString(s);
		}

		public static string Degree2String(double X, eDegree2StringMode Mode)
		{
			string sSign = "", sResult = "", sTmp;
			double xDeg, xMin, xIMin, xSec;
			bool lSign = false;

			if (Mode == eDegree2StringMode.DMSLat)
			{
				lSign = Math.Sign(X) < 0;
				if (lSign)
					X = -X;

				xDeg = System.Math.Floor(X);
				xMin = (X - xDeg) * 60.0;
				xIMin = System.Math.Floor(xMin);
				xSec = (xMin - xIMin) * 60.0;	//		xSec = System.Math.Round((xMin - xIMin) * 60.0, 2);
				if (xSec >= 60.0)
				{
					xSec = 0.0;
					xIMin++;
				}

				if (xIMin >= 60.0)
				{
					xIMin = 0.0;
					xDeg++;
				}

				sTmp = xDeg.ToString("00");
				sResult = sTmp + "°";

				sTmp = xIMin.ToString("00");
				sResult = sResult + sTmp + "'";

				sTmp = xSec.ToString("00.00");
				sResult = sResult + sTmp + @"""";

				return sResult + (lSign ? "S" : "N");
			}

			if (Mode >= eDegree2StringMode.DMSLon)
			{
				X = NativeMethods.Modulus(X);
				lSign = X > 180.0;
				if (lSign) X = 360.0 - X;

				xDeg = System.Math.Floor(X);
				xMin = (X - xDeg) * 60.0;
				xIMin = System.Math.Floor(xMin);
				xSec = (xMin - xIMin) * 60.0;
				if (xSec >= 60.0)
				{
					xSec = 0.0;
					xIMin++;
				}

				if (xIMin >= 60.0)
				{
					xIMin = 0.0;
					xDeg++;
				}

				sTmp = xDeg.ToString("000");
				sResult = sTmp + "°";

				sTmp = xIMin.ToString("00");
				sResult = sResult + sTmp + "'";

				sTmp = xSec.ToString("00.00");
				sResult = sResult + sTmp + @"""";

				return sResult + (lSign ? "W" : "E");
			}

			if (System.Math.Sign(X) < 0) sSign = "-";
			X = NativeMethods.Modulus(System.Math.Abs(X));

			switch (Mode)
			{
				case eDegree2StringMode.DD:
					return sSign + X.ToString("0.0000") + "°";
				case eDegree2StringMode.DM:
					if (System.Math.Sign(X) < 0) sSign = "-";
					X = NativeMethods.Modulus(System.Math.Abs(X));

					xDeg = System.Math.Floor(X);
					xMin = (X - xDeg) * 60.0;
					if (xMin >= 60)
					{
						X++;
						xMin = 0;
					}

					sResult = sSign + xDeg.ToString() + "°";

					sTmp = xMin.ToString("00.0000");
					return sResult + sTmp + "'";
				case eDegree2StringMode.DMS:
					if (System.Math.Sign(X) < 0) sSign = "-";
					X = NativeMethods.Modulus(System.Math.Abs(X));

					xDeg = System.Math.Floor(X);
					xMin = (X - xDeg) * 60.0;
					xIMin = System.Math.Floor(xMin);
					xSec = (xMin - xIMin) * 60.0;
					if (xSec >= 60.0)
					{
						xSec = 0.0;
						xIMin++;
					}

					if (xIMin >= 60.0)
					{
						xIMin = 0.0;
						xDeg++;
					}

					sResult = sSign + xDeg.ToString() + "°";

					sTmp = xIMin.ToString("00");
					sResult = sResult + sTmp + "'";

					sTmp = xSec.ToString("00.00");
					return sResult + sTmp + @"""";
			}
			return sResult;
		}
		#endregion

		#region "Side & Direction Math"

		public static SideDirection SideDef(Point pointOnLine, double lineAngleInRadian, Point testPoint)
		{
			double fdY = testPoint.Y - pointOnLine.Y;
			double fdX = testPoint.X - pointOnLine.X;
			double fDist = fdY * fdY + fdX * fdX;

			if (fDist < Epsilon_2Distance)
				return SideDirection.sideOn;

			double Angle12 = Math.Atan2(fdY, fdX);
			double rAngle = Modulus(lineAngleInRadian - Angle12, C_2xPI);

			if ((rAngle < EpsilonRadian) || (Math.Abs(rAngle - C_PI) < EpsilonRadian))
				return SideDirection.sideOn;

			if (rAngle < ARANMath.C_PI)
				return SideDirection.sideRight;

			return SideDirection.sideLeft;
		}

		public static TurnDirection SideFrom2Angle(double DirInRadian0, double DirInRadian1)
		{
			double rAngle = SubtractAngles(DirInRadian0, DirInRadian1);

			if (C_2xPI - rAngle < EpsilonRadian || rAngle < EpsilonRadian)
				return TurnDirection.NONE;

			rAngle = Modulus(DirInRadian1 - DirInRadian0, C_2xPI);

			if (rAngle < C_PI)
				return TurnDirection.CW;

			return TurnDirection.CCW;
		}

		//public static TurnDirection AnglesSideDef(double DirInRadian0, double DirInRadian1)
		//{
		//    double Z = Modulus(DirInRadian0 - DirInRadian1, C_2xPI);

		//    if (Z == 0.0)
		//        return TurnDirection.NONE;

		//    if (Z > C_PI)
		//        return TurnDirection.CCW;

		//    if (Z < C_PI)
		//        return TurnDirection.CW;

		//    return TurnDirection.CoLinear;
		//}

		public static SideDirection InversDirection(SideDirection Direction)
		{
			return (SideDirection)Enum.ToObject(typeof(SideDirection), -(int)Direction);
		}

		public static TurnDirection InversDirection(TurnDirection Direction)
		{
			return (TurnDirection)Enum.ToObject(typeof(TurnDirection), -(int)Direction);
		}

		public static SideDirection MultiplyDirections(SideDirection Direction1, SideDirection Direction2)
		{
			return (SideDirection)Enum.ToObject(typeof(SideDirection), (int)(Direction1) * (int)(Direction2));
			//SideDirection((int)(Direction1)*(int)(Direction2));
		}

		public static TurnDirection MultiplyDirections(TurnDirection Direction1, TurnDirection Direction2)
		{
			return (TurnDirection)Enum.ToObject(typeof(TurnDirection), (int)(Direction1) * (int)(Direction2));
		}

		public static TurnDirection SideToTurn(SideDirection dir)
		{
			return (TurnDirection)dir;
		}

		public static SideDirection TurnToSide(TurnDirection dir)
		{
			return (SideDirection)dir;
		}

		public static TurnDirection ChangeDirection(TurnDirection dir)
		{
			if (dir == TurnDirection.CCW)
				return TurnDirection.CW;
			if (dir == TurnDirection.CW)
				return TurnDirection.CCW;
			return dir;
		}

		public static SideDirection ChangeDirection(SideDirection dir)
		{
			if (dir == SideDirection.sideLeft)
				return SideDirection.sideRight;
			if (dir == SideDirection.sideRight)
				return SideDirection.sideLeft;
			return dir;
		}
		#endregion

		public static double EnrouteWindSpeed(double altitude)
		{
			return 0.514444444444444444444444 * (0.002 / 0.3048 * altitude + 47.0);
		}

		public static double IASToTAS(double IAS, double H, double dT)
		{
            return IAS * 171233.0 * Math.Sqrt(288.0 + dT - 0.006496 * H) / Math.Pow(288.0 - 0.006496 * H, 2.628);
		}

		public static double IASToTASForRnav(double IASInMetrsInSec, double H, double dT)
		{
			double k = -5.2558761132785;

			double P = 0.01 * 101325 * Math.Pow((288.15 / (288.15 - 0.006496 * H)), k);			//		= 700.94615421975
			double N_H = 288.15 - 0.006496 * H + dT;											//		= 283.5

            double IASinKmpH = IASInMetrsInSec * 3.6;

			//					= 374.32914869661
			return 102.06 / 3.6 * Math.Sqrt(N_H) * Math.Sqrt(Math.Sqrt(1.0 + (0.00067515 * IASinKmpH * IASinKmpH / P) * (1.0 + IASinKmpH * IASinKmpH / 6003025.0)) - 1);
		}

		public static double BankToRadius(double BankInRadian, double TASInMetrsInSec)
		{
			double Rv = 1.76527777777777777777 * Math.Tan(BankInRadian) / (C_PI * TASInMetrsInSec);
			if (Rv > 0.003) Rv = 0.003;

			if (Rv > 0.0)
				return 0.18 * TASInMetrsInSec / (C_PI * Rv);	//(5.555555555555555555555 * C_PI * Rv);

			return -1;
		}

		public static double BankToRadiusForRnav(double BankInRadian, double IASInMetrsInSec, double H, double dT)
		{
			//double k = -5.2558761132785;
			//double P = 0.01 * 101325 * Math.Pow((288.0 / (288.0 - 0.006496 * H)), k);		//		= 700.94615421975
			//double N_H = 288.0 - 0.006496 * H + dT;											//		= 283.5
			//double IASinKmpH = IASInMetrsInSec * 3.6;

			//double TASInMetrsInSec = 102.06 / 3.6 * Math.Sqrt(N_H) * Math.Sqrt(Math.Sqrt(1.0 + (0.00067515 * IASinKmpH * IASinKmpH / P) *
			//                                                (1.0 + IASinKmpH * IASinKmpH / 6003025.0)) - 1.0);
			//                                                                                //		= 374.32914869661

			double TASInMetrsInSec = IASToTASForRnav(IASInMetrsInSec, H, dT);

			double Rv = 1.76527777777777777777 * Math.Tan(BankInRadian) / (C_PI * TASInMetrsInSec);

			if (Rv > 0.003) Rv = 0.003;

			if (Rv > 0.0)
				return TASInMetrsInSec / (5.555555555555555555555 * C_PI * Rv);

			return -1;
		}

		public static double RadiusToBank(double radius, double TASInMetrsInSec)
		{
			if (radius > 0.0)
				return Math.Atan(TASInMetrsInSec * TASInMetrsInSec / (9.807098765432098 * radius));

			return -1;
		}
	}
}


/*
????????????????????????????  
????????????????????????????  
????????????????????????????  
????????????????????????????  
????????????????????????????  
????????????????????????????  
????????????????????????????????  
????????????????????????????????  
?????????????????????????????????  
??????????????????????????????????  
??????????????????????????????????  
??????????????????????????????????  
??????????????????????????????????  
??????????????????????????????????  
??????????????????????????????????  
?????????????????????????????????  
?????????????????????????????????  
?????????????????????????????????  
?????????????????????????????????  
?????????????????????????????????  
????????????????????????????????? Look dude,
????????????????????????????????? a good code!
?????????????????????????????????  
?????????????????????????????????  
?????????????????????????????????  
?????????????????????????????????  
?????????????????????????????????  
?????????????????????????????????  
?????????????????????????????????  
?????????????????????????????????  
?????????????????????????????????  
?????????????????????????????????  
?????????????????????????????????  
?????????????????????????????????  
?????????????????????????????????  
?????????????????????????????????  
?????????????????????????????????  
?????????????????????????????????  
?????????????????????????????????  
?????????????????????????????????  
????????????????????????????????  
????????????????????????????????  
????????????????????????????????  
????????????????????????????????  
????????????????????????????????  
????????????????????????????????  
????????????????????????????????  
????????????????????????????????
*/